import xmltodict

timetrigger = """<math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
              <gt/>
              <csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/time"> time</csymbol>
            </apply>
          </math>"""

kineticlaw = """<math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
              <times/>
              <ci> comp1 </ci>
              <apply>
                <minus/>
                <apply>
                  <times/>
                  <ci> kf_0 </ci>
                  <ci> B </ci>
                </apply>
                <apply>
                  <times/>
                  <ci> kr_0 </ci>
                  <ci> BL </ci>
                </apply>
              </apply>
            </apply>
          </math>"""

def mathmltostr(mathml):
    mathmldict = xmltodict.parse(mathml)['math']
    mathmldict
    print(mathmldict)

import xml.etree.ElementTree as ET

tree = ET.ElementTree(ET.fromstring(kineticlaw))
#tree = ET.ElementTree(ET.fromstring(timetrigger))

operators = {'times': '*',
                 'divide': '/',
                 'plus': '+',
                 'minus': '-'
                 }

def nodestrip(leaf):
    import re

    itemstr = str(leaf)
    itemstr = re.sub('{(.*)}', '', itemstr)
    itemstr = re.search('\'(.*)\'', itemstr).group(1)  # remove mathml url

    if itemstr == "ci" or itemstr == "mi":
        itemstr = str(leaf.text).strip()
        return itemstr

    if itemstr == "cn" or itemstr == "mn":
        itemstr = str(leaf.text).strip()
        return itemstr

    if itemstr == "csymbol" or itemstr == "mo":
        itemstr = str(leaf.text).strip()
        return itemstr

    if itemstr in operators.keys():
        itemstr = operators[itemstr]
        return itemstr

    return itemstr

def treewalk(root = tree.getroot()):

    output = ' '
    if nodestrip(root) == 'apply':
        output += ('(')

    output += nodestrip(root)

    for child in root:
        output+= treewalk(child)

    output += ' '

    if nodestrip(root) == 'apply':
        output += (')')

    return output

# def fixops(equation):
#     equation = str(equation)
#     equation = equation.replace('apply','')
#     equation = list(equation.split())
#
#     output = []
#     i = 0
#
#     def fixed(equation): #checks to see if equation is properly formatted
#
#         for i in range(0, len(equation)-1):
#             if equation[i] in operators.values(): #loop through and check to see that operators are in correct places
#                 if equation[i -1] == '(' or equation[i +1] == ')':
#                     return False
#         else:
#             return True
#
#     while(True):
#
#         if fixed(equation) is True:
#             break
#         print(equation)
#         for i in range(0, len(equation) - 1):
#             if equation[i] in operators.values():
#                 if equation[i + 1] is not '(' :
#                     equation[i], equation[i + 1] = equation[i + 1], equation[i]
#                     break
#                 else:
#                     operator = equation[i]
#                     for j in range(i + 1, len(equation) - 1):
#
#                         if equation[j] is ')':
#                             equation.insert(j,operator)
#                             del equation[i]
#                             break

                        #
                        # print("j = ",j)
                        # if equation[j] == ')':
                        #     print("found ) at index ", j)
                        #
                        #     del equation[i]
                        #     equation.insert(j,temp)
                        #     print(equation)
                        #     break

    # while i < len(equation)-1:
    #
    #     # print('i :',i)
    #     # print('value: ',equation[i])
    #     # print(equation)
    #
    #     if equation[i] in operators.values():
    #         print(equation[i])
    #
    #         if equation[i + 1] is '(':
    #             # temp = equation[i]
    #             # # print("found ( at index ",i+1)
    #             # # print("temp ", temp)
    #             for j in range(i+1,len(equation)-1):
    #
    #                 print(output)
    #
    #                 if equation[j] is  ')':
    #                     output.append(equation[j])
    #                     output.append(equation[i])
    #
    #                     break
    #                 else:
    #                     output.append(equation[j])
    #                 #
    #                 # print("j = ",j)
    #                 # if equation[j] == ')':
    #                 #     print("found ) at index ", j)
    #                 #
    #                 #     del equation[i]
    #                 #     equation.insert(j,temp)
    #                 #     print(equation)
    #                 #     break
    #
    #         else:
    #             output.append(equation[i+1])
    #             output.append(equation[i])
    #             equation[i],equation[i + 1]= equation[i+1],equation[i]
    #             i += 1
    #
    #     #else:
    #         #output.append(equation[i])
    #     print(output)
    #
    #     i +=1


    return equation

# ['math', '(', '*', 'comp1', '(', '-', '(', '*', 'kf_0', 'B', ')', '(', '*', 'kr_0', 'BL', ')', ')', ')']
# ['math', '(', 'comp1', '*', '(', '-', '(', 'kf_0', 'B', ')', '*', '(', 'kr_0', 'BL', ')', ')', ')', '*']


print(fixops(treewalk()))



#treelist = list(tree.iter())


# itemlist = []
# for item in treelist:
#     import re
#
#     itemstr = str(item)
#     itemstr = re.sub('{(.*)}', '', itemstr)
#     itemstr = re.search('\'(.*)\'', itemstr).group(1)  # remove mathml url
#
#     if itemstr == "ci" or itemstr == "mi":
#         itemstr = str(item.text).strip()
#
#     if itemstr == "cn" or itemstr == "mn":
#         itemstr = str(item.text).strip()
#
#     if itemstr == "csymbol" or itemstr == "mo":
#         itemstr = str(item.text).strip()
#
#     if itemstr in operators.keys():
#         itemstr = operators[itemstr]
#
#     itemlist.append(itemstr)



